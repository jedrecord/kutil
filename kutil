#!/bin/env bash
#

#*************************************************************************
#
# WARNING! THIS VERSION IS DEPRECIATED
#
# Please download the latest version from:
#     https://github.com/jedrecord/kutil/releases
#
# This shell script is just a hacked wrapper around kubectl commands.
# It is slow and innefficient.
# I've updated the reposiory with a newer version which uses the native
# Kubernetes API in go. I highly recommend using the binary version for
# your platform.
#
#*************************************************************************

#  kutil - Display a summary of Kubernetes node and cluster resource utilization by memory, cpu, and pods
#
#  Author:   Jed Record <jed@jedrecord.com>
#
#  Copyright (C) 2020 Jed Record
#

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; Version 2 (GPLv2)

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Full license text at: https://gnu.org/licenses/gpl-2.0.txt

NAME="kutil"
PURPOSE="Display a summary of Kubernetes node and cluster resource utilization by memory, cpu, and pods"
VERSION="0.8.1"
AUTHOR="Jed Record"
EMAIL="jed@jedrecord.com"
WEB="https://github.com/jedrecord/kutil"
COPYRIGHT="Copyright (C) 2020 Jed Record
License GNU GPL version 2 <https://gnu.org/licenses/gpl-2.0.html>
This is free software; you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law."
USAGE="Usage: kutil [OPTIONS]"
SUMMARY="${USAGE}
 Option                    Meaning
 -h, --help                Show usage and options
 -i, --infra               Show only nodes labelled 'infra'
 -l, --label LABEL[=VALUE] Show nodes with label and optional value
 -m, --masters             Show only nodes labelled 'master'
 -s, --schedulable         Show only nodes without a 'NoSchedule' taint
 -v, --version             Print version info
 -w, --workers             Show only nodes labelled as workers
 "
NAME_PADDING_CHARS=25

main() {
  label="node"
  while getopts ":-:hil:msvw" opt; do
    case "$opt" in
        -) long_opt="${OPTARG}"
           shift $((OPTIND -1))
           check_long_opts "${long_opt}" "$1" ;;
        h) show_help ;;
        i) opt_infra=true ;;
        l) opt_label=true
           label=${OPTARG} ;;
        m) opt_masters=true ;;
        s) opt_schedulable=true ;;
        v) show_version ;;
        w) opt_workers=true ;;
       \?) show_error "\"-${OPTARG}\" is an invalid option" ;;
        :) show_error "The option \"-${OPTARG}\" requires an argumemt." ;;
    esac
  done
  if [ $? -ne 0 ];then opt_none=true; fi
  shift $((OPTIND -1))

  declare -a all_nodes
  if [[ $opt_label == true ]]
  then
    label=${label/=/:}
    all_nodes=$(kubectl get nodes --no-headers -o custom-columns=NAME:.metadata.name,LABELS:.metadata.labels | awk -v label="\/${label}" '{n=$1;$1=""} $0 ~ label {print n}' 2>/dev/null)
  elif [[ $opt_schedulable == true ]]
  then
    all_nodes=$(kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.spec.taints[?(@.effect=="NoSchedule")].effect}{"\n"}{end}'|grep -v NoSchedule 2>/dev/null)
  elif [[ $opt_infra == true || $opt_masters == true || $opt_workers == true ]]
  then
    if [[ $opt_infra == true ]]
    then
      all_nodes=$(kubectl get nodes --no-headers --selector=node-role.kubernetes.io/infra -o custom-columns=NAME:.metadata.name 2>/dev/null)
    fi
    if [[ $opt_masters == true ]]
    then
      all_nodes="$(kubectl get nodes --no-headers -o custom-columns=NAME:.metadata.name,LABELS:.metadata.labels | awk -v pattern="node(-role)?\.kubernetes\.io\/(master|controlplane|etcd):" '{n=$1;$1=""} $0 ~ pattern {print n}' 2>/dev/null) ${all_nodes}"
    fi
    if [[ $opt_workers == true ]]
    then
      all_nodes="$(kubectl get nodes --no-headers -o custom-columns=NAME:.metadata.name,LABELS:.metadata.labels | awk -v pattern="node(-role)?\.kubernetes\.io\/(compute|worker|minion):" '{n=$1;$1=""} $0 ~ pattern {print n}' 2>/dev/null) ${all_nodes}"
    fi
  else
    all_nodes=$(kubectl get nodes --no-headers -o custom-columns=NAME:.metadata.name 2>/dev/null)
  fi

  empty='^\s+?$'
  if [[ ${all_nodes} =~ ${empty} ]]
  then
    echo "No nodes match your selection criteria"
    exit 1
  fi

  local nodelabel="$(namepad NODE)"
  echo -e "${nodelabel} LABEL\t\tCPU\tRAM\tPODS"

  declare -A seen
  for node in $all_nodes
  do
    # Don't duplicate nodes
    if [[ ${seen[$node]} -ne 1 ]]
    then
      _kutil_requests=$(kubectl describe node ${node} | grep -A3 -E "\\s\sRequests" | tail -n2)
      _kutil_percent_cpu=$(echo ${_kutil_requests} | awk -F "[()%]" '{print $2}')
      _kutil_percent_mem=$(echo ${_kutil_requests} | awk -F "[()%]" '{print $8}')
      _kutil_pods_running=$(kubectl describe node ${node} | awk '/Non-terminated Pods/ {match($3,/\(([0-9]+)/,n);print n[1]}')
      _kutil_pods_cap=$(kubectl get node ${node} -o jsonpath={.status.capacity.pods})
      _kutil_percent_pods=$((100 * _kutil_pods_running / _kutil_pods_cap))
      _kutil_cores=$(to_milli $(kubectl get node ${node} -o jsonpath={.status.allocatable.cpu}))
      _kutil_ram=$(to_kb $(kubectl get node ${node} -o jsonpath={.status.allocatable.memory}))
      _kutil_allocated_cpu=$(to_milli $(kubectl describe node ${node} | awk '/^  cpu / {print $2}'))
      _kutil_allocated_mem=$(to_kb $(kubectl describe node ${node} | awk '/^  memory / {print $2}'))
      _kutil_role="$(kubectl describe node ${node}|grep Roles|awk '{print $2}')"
  
      local nodename="$(namepad ${node})"
      echo -e "${nodename} ${_kutil_role}  \t${_kutil_percent_cpu}%\t${_kutil_percent_mem}%\t${_kutil_percent_pods}%"
    
      node_count=$((node_count + 1))
      pods_allocated=$((pods_allocated + _kutil_pods_running))
      pods_capacity=$((pods_capacity + _kutil_pods_cap))
      total_percent_cpu=$((total_percent_cpu + _kutil_percent_cpu))
      total_percent_mem=$((total_percent_mem + _kutil_percent_mem))
      cpu_avail=$((cpu_avail + _kutil_cores))
      mem_avail=$((mem_avail + _kutil_ram))
      cpu_alloc=$((cpu_alloc + _kutil_allocated_cpu))
      mem_alloc=$((mem_alloc + _kutil_allocated_mem))
  
      # Clear vars
      unset $(compgen -v | grep "^_kutil_")
      seen[$node]=1
    fi
  done
  
  avg_percent_cpu=$((total_percent_cpu / node_count))
  avg_percent_mem=$((total_percent_mem / node_count))
  pod_alloc_pct=$(awk -v a=${pods_allocated} -v b=${pods_capacity} 'BEGIN { print ( 100 * a / b ) }')
  tot_cpu_pct=$(awk -v a=${cpu_alloc} -v b=${cpu_avail} 'BEGIN { print ( 100 * a / b ) }')
  tot_mem_pct=$(awk -v a=${mem_alloc} -v b=${mem_avail} 'BEGIN { print ( 100 * a / b ) }')
  
  outp="$(printf "CPU,%.1f of %.1f cores,(%.2f%%)\n" $(awk "BEGIN{print $cpu_alloc/1000}") $(awk "BEGIN{print $cpu_avail/1000}") ${tot_cpu_pct})\n"
  outp+="$(printf "RAM,%d of %d Gb,(%.2f%%)\n" $(to_gb ${mem_alloc}) $(to_gb ${mem_avail}) ${tot_mem_pct})\n"
  outp+="$(printf "PODS,%d of %d pods,(%.2f%%)\n" ${pods_allocated} ${pods_capacity} ${pod_alloc_pct})\n"
  
  echo
  echo "Total Utilization"
  echo -e ${outp} | column -t -s "," -o "    "
}

#
# Functions
#
check_long_opts(){
  local long_option="$1"
  local param="$2"
  case ${long_option} in
    help) show_help ;;
    infra) opt_infra=true ;;
    label) opt_label=true
           label="${param}" ;;
    masters) opt_masters=true ;;
    schedulable) opt_schedulable=true ;;
    version) show_version ;;
    workers) opt_workers=true ;;
    *) show_error "\"--${long_option}\" is an invalid option" ;;
  esac
}
show_version(){
  echo "kutil version ${VERSION}"
  echo "${COPYRIGHT}"
  echo
  echo "Contact: ${AUTHOR} <${EMAIL}>"
  echo "Website: ${WEB}"
  exit 0
}
show_help(){
  echo "kutil version ${VERSION}"
  echo "${PURPOSE}"
  echo "${SUMMARY}"
  echo
  echo "Contact: ${AUTHOR} <${EMAIL}>"
  echo "Website: ${WEB}"
  exit 0
}
show_error(){
  echo "$1" 1>&2
  echo "${USAGE}"
  echo "Try 'kutil --help' for more information."
  exit 1
}
to_milli() {
  local n=$1
  if [[ $n =~ m$ ]]
  then
    echo ${n%m}
  else
    echo $(( $n * 1000 ))
  fi
}
to_kb() {
  local n=$1
  if [[ $n =~ i$ ]]
  then
    echo $n | numfmt --from=iec-i --to-unit=K
  else
    echo $n | numfmt --from=iec --to-unit=K
  fi
}
to_gb() {
  echo $1 | numfmt --from-unit=K --to-unit=G
}
namepad() {
  local name="$1"
  printf '%s%*s' "${name}" $((${NAME_PADDING_CHARS} - ${#name})) " "
}
#
# End functions
#
main $@
